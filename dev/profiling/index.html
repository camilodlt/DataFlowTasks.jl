<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Debugging &amp; Profiling · DataFlowTasks.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://maltezfaria.github.io/DataFlowTasks.jl/profiling/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataFlowTasks.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting started</a></li><li class="is-active"><a class="tocitem" href>Debugging &amp; Profiling</a><ul class="internal"><li><a class="tocitem" href="#Cleaning-the-internal-state"><span>Cleaning the internal state</span></a></li><li><a class="tocitem" href="#DAG-visualization"><span>DAG visualization</span></a></li><li><a class="tocitem" href="#Scheduling-and-profiling-information"><span>Scheduling and profiling information</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/cholesky/cholesky/">Tiled Cholesky Factorization</a></li><li><a class="tocitem" href="../examples/stencil/stencil/">Iterative Stencil Loop</a></li><li><a class="tocitem" href="../examples/lu/lu/">Tiled LU factorization</a></li><li><a class="tocitem" href="../examples/hmat/hmat/">Hierarchical <code>LU</code> factorization</a></li></ul></li><li><a class="tocitem" href="../issues/">Common Issues</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Debugging &amp; Profiling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Debugging &amp; Profiling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maltezfaria/DataFlowTasks.jl/blob/main/docs/src/profiling.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="visualization-section"><a class="docs-heading-anchor" href="#visualization-section">Debugging &amp; Profiling</a><a id="visualization-section-1"></a><a class="docs-heading-anchor-permalink" href="#visualization-section" title="Permalink"></a></h1><p><code>DataFlowTasks</code> defines two visualization tools that help when debugging and profiling parallel programs:</p><ul><li>a visualization of the Directed Acyclic Graph (DAG) internally representing task dependencies;</li><li>a visualization of how tasks were scheduled during a run, alongside with other information helping understand what limits the performances of the computation.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Visualization tools require additional dependencies (such as <code>Makie</code> or <code>GraphViz</code>) which are only needed during the development stage. We are therefore only declaring those as <em>optional dependencies</em> (using <code>Requires.jl</code>) and it is currently up to the user to set up a stacked environment in which these dependencies are available.</p></div></div><p>Let&#39;s first introduce a small example that will help illustrate the features introduced here:</p><pre><code class="language-julia hljs">using DataFlowTasks

# Utility functions
init!(x)    = (x .= rand())     # Write
mutate!(x)  = (x .= exp.(x))    # Read+Write
result(x,y) = sum(x) + sum(y)   # Read

# Main work function
function work(A, B)
    # Initialization
    @dspawn init!(@W(A))               label=&quot;init A&quot;
    @dspawn init!(@W(B))               label=&quot;init B&quot;

    # Mutation
    @dspawn mutate!(@RW(A))            label=&quot;mutate A&quot;
    @dspawn mutate!(@RW(B))            label=&quot;mutate B&quot;

    # Final read
    res = @dspawn result(@R(A), @R(B)) label=&quot;read A,B&quot;
    fetch(res)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">work (generic function with 1 method)</code></pre><h2 id="Cleaning-the-internal-state"><a class="docs-heading-anchor" href="#Cleaning-the-internal-state">Cleaning the internal state</a><a id="Cleaning-the-internal-state-1"></a><a class="docs-heading-anchor-permalink" href="#Cleaning-the-internal-state" title="Permalink"></a></h2><p>When debugging and profiling, it is usually preferable to always start experiments in a clean state. This helps avoiding interferences caused by previous (possibly bugged) runs.</p><p>Before running our example, we&#39;ll call <a href="../references/#DataFlowTasks.resetlogger!"><code>resetlogger!</code></a> in order to clean up the logging information that could linger in <code>DataFlowTasks</code> from previous experiments:</p><pre><code class="language-julia hljs">DataFlowTasks.resetlogger!()</code></pre><p>We can now run the example:</p><pre><code class="language-julia hljs"># Context
A = ones(2000, 2000)
B = ones(3000, 3000)

work(copy(A), copy(B))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3.021256911742307e7</code></pre><h2 id="DAG-visualization"><a class="docs-heading-anchor" href="#DAG-visualization">DAG visualization</a><a id="DAG-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#DAG-visualization" title="Permalink"></a></h2><p>In order to better understand what this example does, and check that <em>data dependencies</em> were suitably annotated, it can be useful to look at the Directed Acyclic Graph (DAG) representing <em>task dependencies</em> as they were inferred by <code>DataFlowTasks</code>. The DAG can be visualized with the <a href="../references/#DataFlowTasks.dagplot"><code>dagplot</code></a> function:</p><pre><code class="language-julia hljs">using GraphViz
DataFlowTasks.dagplot()</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.50.0 (20211204.2007)
 -->
<!-- Title: dag Pages: 1 -->
<svg width="240pt" height="188pt"
 viewBox="0.00 0.00 240.24 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>dag</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-184 236.24,-184 236.24,4 -4,4"/>
<!-- 1 -->
<g id="node1" class="node">
<title>1</title>
<ellipse fill="none" stroke="black" stroke-width="2" cx="53.3" cy="-162" rx="36" ry="18"/>
<text text-anchor="middle" x="53.3" y="-158.3" font-family="Times,serif" font-size="14.00">init A</text>
</g>
<!-- 3 -->
<g id="node3" class="node">
<title>3</title>
<ellipse fill="none" stroke="black" stroke-width="2" cx="53.3" cy="-90" rx="53.09" ry="18"/>
<text text-anchor="middle" x="53.3" y="-86.3" font-family="Times,serif" font-size="14.00">mutate A</text>
</g>
<!-- 1&%2345;&gt;3 -->
<g id="edge1" class="edge">
<title>1&%2345;&gt;3</title>
<path fill="none" stroke="black" stroke-width="2" d="M53.3,-143.7C53.3,-135.98 53.3,-126.71 53.3,-118.11"/>
<polygon fill="black" stroke="black" stroke-width="2" points="56.8,-118.1 53.3,-108.1 49.8,-118.1 56.8,-118.1"/>
</g>
<!-- 2 -->
<g id="node2" class="node">
<title>2</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="178.3" cy="-162" rx="36.29" ry="18"/>
<text text-anchor="middle" x="178.3" y="-158.3" font-family="Times,serif" font-size="14.00">init B</text>
</g>
<!-- 4 -->
<g id="node4" class="node">
<title>4</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="178.3" cy="-90" rx="53.89" ry="18"/>
<text text-anchor="middle" x="178.3" y="-86.3" font-family="Times,serif" font-size="14.00">mutate B</text>
</g>
<!-- 2&%2345;&gt;4 -->
<g id="edge2" class="edge">
<title>2&%2345;&gt;4</title>
<path fill="none" stroke="red" stroke-width="2" d="M178.3,-143.7C178.3,-135.98 178.3,-126.71 178.3,-118.11"/>
<polygon fill="red" stroke="red" stroke-width="2" points="181.8,-118.1 178.3,-108.1 174.8,-118.1 181.8,-118.1"/>
</g>
<!-- 5 -->
<g id="node5" class="node">
<title>5</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="115.3" cy="-18" rx="50.89" ry="18"/>
<text text-anchor="middle" x="115.3" y="-14.3" font-family="Times,serif" font-size="14.00">read A,B</text>
</g>
<!-- 3&%2345;&gt;5 -->
<g id="edge4" class="edge">
<title>3&%2345;&gt;5</title>
<path fill="none" stroke="black" stroke-width="2" d="M67.99,-72.41C75.71,-63.69 85.32,-52.85 93.85,-43.21"/>
<polygon fill="black" stroke="black" stroke-width="2" points="96.7,-45.28 100.71,-35.47 91.46,-40.64 96.7,-45.28"/>
</g>
<!-- 4&%2345;&gt;5 -->
<g id="edge3" class="edge">
<title>4&%2345;&gt;5</title>
<path fill="none" stroke="red" stroke-width="2" d="M163.37,-72.41C155.44,-63.61 145.56,-52.63 136.82,-42.92"/>
<polygon fill="red" stroke="red" stroke-width="2" points="139.41,-40.56 130.12,-35.47 134.21,-45.24 139.41,-40.56"/>
</g>
</g>
</svg>
'/><p>When the working environment supports rich media, the DAG will be displayed automatically. In other cases, it is possible to export it to an image using <a href="../references/#DataFlowTasks.savedag-Tuple{String, GraphViz.Graph}"><code>savedag</code></a>:</p><pre><code class="language-julia hljs">g = DataFlowTasks.dagplot()
DataFlowTasks.savedag(&quot;profiling-example.svg&quot;, g)</code></pre><p>Note how the task labels (which were provided as extra arguments to <code>@dspawn</code>) are used in the DAG rendering and make it more readable. In the DAG visualization, the <em>critical path</em> is highlighted in red: it is the sequential path that took the longest run time during the computation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The run time of this critical path imposes a hard bound on parallel performances: no matter how many threads are available, it is not possible for the computation to take less time than the duration of the critical path.</p></div></div><h2 id="Scheduling-and-profiling-information"><a class="docs-heading-anchor" href="#Scheduling-and-profiling-information">Scheduling and profiling information</a><a id="Scheduling-and-profiling-information-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling-and-profiling-information" title="Permalink"></a></h2><p>As said before, profiling should be performed in a state that is as clean as possible. Moreover, unless one is interested in compilation times, profiling information should also be collected from a computation in which everything was already available in compiled form.</p><p>Let us then consider the previous computation as a &quot;dry run&quot; used to force all code to get compiled, and re-run the computation to collect clean profiling data:</p><pre><code class="language-julia hljs">DataFlowTasks.resetlogger!()
GC.gc()

work(A, B)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2.845138162639767e7</code></pre><p>The collected scheduling &amp; profiling information can be visualized in a graph produced by the <a href="../references/#DataFlowTasks.plot"><code>DataFlowTasks.plot</code></a> function (note that it requires a <code>Makie</code> backend; using <code>GLMakie</code> brings a bit more interactivity than <code>CairoMakie</code>):</p><pre><code class="language-julia hljs">using CairoMakie # or GLMakie to benefit from more interactivity
DataFlowTasks.plot(categories=[&quot;init&quot;, &quot;mutate&quot;, &quot;read&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Computing    : 0.07063036
[ Info: Inserting    : 8.500000000000002e-6
[ Info: Other        : 2.780000002895986e-5</code></pre><p><img src="../profiling_example.png" alt="ProfilingExampleTrace"/></p><p>The <code>categories</code> keyword argument allows grouping tasks in categories according to their labels. In the example above, all tasks containing <code>&quot;mutate&quot;</code> in their label will be grouped in the same category.</p><p>Note : be careful with giving similar labels. If tasks have &quot;R&quot; and &quot;RW&quot; labels, and the substrings given to the plot&#39;s argument are also &quot;R&quot;, and &quot;RW&quot;, then all tasks will be in the category &quot;R&quot; (because &quot;R&quot; can be found in &quot;RW&quot;). Regular expressions can be given instead of substrings in order to avoid such issues.</p><p>Let us explore the various parts of this graph.</p><h3 id="Parallel-Trace"><a class="docs-heading-anchor" href="#Parallel-Trace">Parallel Trace</a><a id="Parallel-Trace-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Trace" title="Permalink"></a></h3><p>The main plot (at the top) is the parallel trace visualization. In this example there were two threads; we can see on which thread the task was run, and the time it took.</p><p>Even though tasks are grouped in categories by considering substrings in their labels, the full label is shown when hovering over a task in the interactive visualization (i.e. when using <code>GLMakie</code> instead of <code>CairoMakie</code>).</p><p>The plot also shows the time spent inserting nodes in the graph (which is part of the overhead incurred by the use of <code>DataFlowTasks</code>): these insertion times are visualized as red tasks. They are not visible for such a small example, but the interactive visualization allows zooming on the plot to search for those small tasks.</p><p>Also note that inserting tasks into the graph involves memory allocations, and may thus trigger garbage collector sweeps. When this happens, the time spent in the garbage collector is also shown in the plot.</p><h3 id="Activity-plot"><a class="docs-heading-anchor" href="#Activity-plot">Activity plot</a><a id="Activity-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Activity-plot" title="Permalink"></a></h3><p>The &quot;activity&quot; barplot (in the bottom left corner of the window) gives us information on the break-down of parallel computing times (summed over all threads):</p><ul><li><code>Computing</code> represents the total time spent in the tasks bodies (i.e. &quot;useful&quot; work);</li><li><code>Inserting</code> represents the total time spent inserting nodes in the DAG (i.e. overhead induced by <code>DataFlowTasks</code>), possibly including any time spent in the GC if it is triggered by a memory allocation in the task insertion process;</li><li><code>Other</code> represents the total idle time on all threads (which may be due to bad scheduling, or simply arise by lack of enough exposed parallelism in the algorithm).</li></ul><h3 id="Time-Bounds-plot"><a class="docs-heading-anchor" href="#Time-Bounds-plot">Time Bounds plot</a><a id="Time-Bounds-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Bounds-plot" title="Permalink"></a></h3><p>The &quot;Time Bounds&quot; barplot (in the bottom center of the window) tries to present insightful information about the performance limiting factors in the computation:</p><ul><li><code>critical path</code> represents the time spent in the longest sequential path in the DAG (shown in red in the DAG visualization). As said above, it bounds the performance in that even infinitely many threads would still have to compute this path sequentially;</li><li><code>without waiting</code> represents the duration of a hypothetical computation in which all computing time would be evenly distributed among threads (i.e. no thread would ever have to wait). This also bounds the total time because it does not account for dependencies between tasks.</li><li><code>Real</code> represents the measured &quot;wall clock time&quot; of the computation; it should be larger than both of the aforementioned bounds.</li></ul><p>When looking for faster response times, this graph may suggest sensible ways to explore. If the measured time is close to the critical path duration, then adding more threads will be of no help, but decomposing the work in smaller tasks may be useful. On the other hand, if the measured time is close to the &quot;without waiting&quot; bound, then adding more workers may reduce the wall clock time and scale relatively well.</p><h3 id="Times-per-Category-plot"><a class="docs-heading-anchor" href="#Times-per-Category-plot">Times per Category plot</a><a id="Times-per-Category-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Times-per-Category-plot" title="Permalink"></a></h3><p>The &quot;Times per Category&quot; barplot (in the bottom right of the window) displays the total time spent on all threads while performing user-defined tasks (grouped by category as explained above).</p><p>When trying to optimize the sequential performance of the algorithm, this is where one can get data about what actually takes time (and therefore could produce large gains in performance if it could be optimized).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Getting started</a><a class="docs-footer-nextpage" href="../examples/cholesky/cholesky/">Tiled Cholesky Factorization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 6 September 2022 13:37">Tuesday 6 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
