<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Debugging &amp; Profiling · DataFlowTasks.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://maltezfaria.github.io/DataFlowTasks.jl/profiling/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataFlowTasks.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Getting started</a></li><li class="is-active"><a class="tocitem" href>Debugging &amp; Profiling</a><ul class="internal"><li><a class="tocitem" href="#Creating-a-[Logger](@ref-DataFlowTasks.Logger)"><span>Creating a <code>Logger</code></span></a></li><li><a class="tocitem" href="#DAG-visualization"><span>DAG visualization</span></a></li><li><a class="tocitem" href="#Scheduling-and-profiling-information"><span>Scheduling and profiling information</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/cholesky/cholesky/">Tiled Cholesky Factorization</a></li><li><a class="tocitem" href="../examples/blur-roberts/blur-roberts/">Blur &amp; Roberts image filters</a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Debugging &amp; Profiling</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Debugging &amp; Profiling</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maltezfaria/DataFlowTasks.jl/blob/main/docs/src/profiling.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="visualization-section"><a class="docs-heading-anchor" href="#visualization-section">Debugging &amp; Profiling</a><a id="visualization-section-1"></a><a class="docs-heading-anchor-permalink" href="#visualization-section" title="Permalink"></a></h1><p><code>DataFlowTasks</code> defines two visualization tools that help when debugging and profiling parallel programs:</p><ul><li>a visualization of the Directed Acyclic Graph (DAG) internally representing task dependencies;</li><li>a visualization of how tasks were scheduled during a run, alongside with other information helping understand what limits the performances of the computation.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Visualization tools require additional dependencies (such as <code>Makie</code> or <code>GraphViz</code>) which are only needed during the development stage. We are therefore only declaring those as <em>optional dependencies</em> (using <code>Requires.jl</code>). The user can either set up a stacked environment in which these dependencies are available, or use the  <a href="../references/#DataFlowTasks.@using_opt-Tuple{Any}"><code>DataFlowTasks.@using_opt</code></a> macro which to handle the environment automatically.</p></div></div><p>Let&#39;s first introduce a small example that will help illustrate the features introduced here:</p><pre><code class="language-julia hljs">using DataFlowTasks

# Utility functions
init!(x)    = (x .= rand())     # Write
mutate!(x)  = (x .= exp.(x))    # Read+Write
result(x,y) = sum(x) + sum(y)   # Read

# Main work function
function work(A, B)
    # Initialization
    @dspawn init!(@W(A))               label=&quot;init A&quot;
    @dspawn init!(@W(B))               label=&quot;init B&quot;

    # Mutation
    @dspawn mutate!(@RW(A))            label=&quot;mutate A&quot;
    @dspawn mutate!(@RW(B))            label=&quot;mutate B&quot;

    # Final read
    res = @dspawn result(@R(A), @R(B)) label=&quot;read A,B&quot;
    fetch(res)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">work (generic function with 1 method)</code></pre><h2 id="Creating-a-[Logger](@ref-DataFlowTasks.Logger)"><a class="docs-heading-anchor" href="#Creating-a-[Logger](@ref-DataFlowTasks.Logger)">Creating a <a href="../references/#DataFlowTasks.Logger"><code>Logger</code></a></a><a id="Creating-a-[Logger](@ref-DataFlowTasks.Logger)-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-a-[Logger](@ref-DataFlowTasks.Logger)" title="Permalink"></a></h2><p>In order to inspect code which makes use of <code>DataFlowTask</code>s, you can use the <a href="../references/#DataFlowTasks.@log-Tuple{Any, Any}"><code>DataFlowTasks.@log</code></a> macro to keep a trace of the various parallel events and the underlying <code>DAG</code>. Note that to avoid profiling the compilation time, it is often advisable to perform a &quot;dry run&quot; of the code first, as done in the example below:</p><pre><code class="language-julia hljs"># Context
A = ones(2000, 2000)
B = ones(3000, 3000)

# precompilation run
work(copy(A),copy(B))

# activate logging of events
logger = DataFlowTasks.@log work(A, B)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataFlowTasks.Logger(Vector{DataFlowTasks.TaskLog}[[DataFlowTasks.TaskLog(835, 0x000000d285c7494f, 0x000000d285f4d50f, 1, Int64[], &quot;init A&quot;), DataFlowTasks.TaskLog(836, 0x000000d285f4fe77, 0x000000d2865b3984, 1, Int64[], &quot;init B&quot;), DataFlowTasks.TaskLog(837, 0x000000d2865b6418, 0x000000d28848408e, 1, [835], &quot;mutate A&quot;), DataFlowTasks.TaskLog(838, 0x000000d288486c4e, 0x000000d28c99dec9, 1, [836], &quot;mutate B&quot;), DataFlowTasks.TaskLog(839, 0x000000d28c9a10c9, 0x000000d28d181f70, 1, [837, 838], &quot;read A,B&quot;)]], Vector{DataFlowTasks.InsertionLog}[[DataFlowTasks.InsertionLog(0x000000d285c68983, 0x000000d285c697f7, 0, 835, 1), DataFlowTasks.InsertionLog(0x000000d285c6b15b, 0x000000d285c6b92b, 0, 836, 1), DataFlowTasks.InsertionLog(0x000000d285c6c92f, 0x000000d285c6cddf, 0, 837, 1), DataFlowTasks.InsertionLog(0x000000d285c6e09f, 0x000000d285c6e22f, 0, 838, 1), DataFlowTasks.InsertionLog(0x000000d285c70eb7, 0x000000d285c7174f, 0, 839, 1)]])</code></pre><p>The <code>logger</code> object above, of <a href="../references/#DataFlowTasks.Logger"><code>Logger</code></a> type, stores various information that can be used to reconstruct both the inferred dependencies and the parallel execution traces of the <code>DataFlowTask</code>s, as illustrated next.</p><h2 id="DAG-visualization"><a class="docs-heading-anchor" href="#DAG-visualization">DAG visualization</a><a id="DAG-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#DAG-visualization" title="Permalink"></a></h2><p>In order to better understand what this example does, and check that <em>data dependencies</em> were suitably annotated, it can be useful to look at the Directed Acyclic Graph (DAG) representing <em>task dependencies</em> as they were inferred by <code>DataFlowTasks</code>. The DAG can be visualized with the <a href="../references/#DataFlowTasks.dagplot-Tuple{Any}"><code>dagplot</code></a> function:</p><pre><code class="language-julia hljs">DataFlowTasks.@using_opt GraphViz # or `using GraphViz` if your environment has it
DataFlowTasks.dagplot(logger)</code></pre><img src='data:image/svg+xml;utf-8,<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.50.0 (20211204.2007)
 -->
<!-- Title: dag Pages: 1 -->
<svg width="240pt" height="188pt"
 viewBox="0.00 0.00 240.24 188.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)">
<title>dag</title>
<polygon fill="white" stroke="transparent" points="-4,4 -4,-184 236.24,-184 236.24,4 -4,4"/>
<!-- 835 -->
<g id="node1" class="node">
<title>835</title>
<ellipse fill="none" stroke="black" stroke-width="2" cx="53.3" cy="-162" rx="36" ry="18"/>
<text text-anchor="middle" x="53.3" y="-158.3" font-family="Times,serif" font-size="14.00">init A</text>
</g>
<!-- 837 -->
<g id="node3" class="node">
<title>837</title>
<ellipse fill="none" stroke="black" stroke-width="2" cx="53.3" cy="-90" rx="53.09" ry="18"/>
<text text-anchor="middle" x="53.3" y="-86.3" font-family="Times,serif" font-size="14.00">mutate A</text>
</g>
<!-- 835&%2345;&gt;837 -->
<g id="edge1" class="edge">
<title>835&%2345;&gt;837</title>
<path fill="none" stroke="black" stroke-width="2" d="M53.3,-143.7C53.3,-135.98 53.3,-126.71 53.3,-118.11"/>
<polygon fill="black" stroke="black" stroke-width="2" points="56.8,-118.1 53.3,-108.1 49.8,-118.1 56.8,-118.1"/>
</g>
<!-- 836 -->
<g id="node2" class="node">
<title>836</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="178.3" cy="-162" rx="36.29" ry="18"/>
<text text-anchor="middle" x="178.3" y="-158.3" font-family="Times,serif" font-size="14.00">init B</text>
</g>
<!-- 838 -->
<g id="node4" class="node">
<title>838</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="178.3" cy="-90" rx="53.89" ry="18"/>
<text text-anchor="middle" x="178.3" y="-86.3" font-family="Times,serif" font-size="14.00">mutate B</text>
</g>
<!-- 836&%2345;&gt;838 -->
<g id="edge2" class="edge">
<title>836&%2345;&gt;838</title>
<path fill="none" stroke="red" stroke-width="2" d="M178.3,-143.7C178.3,-135.98 178.3,-126.71 178.3,-118.11"/>
<polygon fill="red" stroke="red" stroke-width="2" points="181.8,-118.1 178.3,-108.1 174.8,-118.1 181.8,-118.1"/>
</g>
<!-- 839 -->
<g id="node5" class="node">
<title>839</title>
<ellipse fill="none" stroke="red" stroke-width="2" cx="115.3" cy="-18" rx="50.89" ry="18"/>
<text text-anchor="middle" x="115.3" y="-14.3" font-family="Times,serif" font-size="14.00">read A,B</text>
</g>
<!-- 837&%2345;&gt;839 -->
<g id="edge3" class="edge">
<title>837&%2345;&gt;839</title>
<path fill="none" stroke="black" stroke-width="2" d="M67.99,-72.41C75.71,-63.69 85.32,-52.85 93.85,-43.21"/>
<polygon fill="black" stroke="black" stroke-width="2" points="96.7,-45.28 100.71,-35.47 91.46,-40.64 96.7,-45.28"/>
</g>
<!-- 838&%2345;&gt;839 -->
<g id="edge4" class="edge">
<title>838&%2345;&gt;839</title>
<path fill="none" stroke="red" stroke-width="2" d="M163.37,-72.41C155.44,-63.61 145.56,-52.63 136.82,-42.92"/>
<polygon fill="red" stroke="red" stroke-width="2" points="139.41,-40.56 130.12,-35.47 134.21,-45.24 139.41,-40.56"/>
</g>
</g>
</svg>
'/><p>When the working environment supports rich media, the DAG will be displayed automatically. In other cases, it is possible to export it to an image using <a href="../references/#DataFlowTasks.savedag-Tuple{String, GraphViz.Graph}"><code>savedag</code></a>:</p><pre><code class="language-julia hljs">g = DataFlowTasks.dagplot(logger)
DataFlowTasks.savedag(&quot;profiling-example.svg&quot;, g)</code></pre><p>Note how the task labels (which were provided as extra arguments to <code>@dspawn</code>) are used in the DAG rendering and make it more readable. In the DAG visualization, the <em>critical path</em> is highlighted in red: it is the sequential path that took the longest run time during the computation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The run time of this critical path imposes a hard bound on parallel performances: no matter how many threads are available, it is not possible for the computation to take less time than the duration of the critical path.</p></div></div><h2 id="Scheduling-and-profiling-information"><a class="docs-heading-anchor" href="#Scheduling-and-profiling-information">Scheduling and profiling information</a><a id="Scheduling-and-profiling-information-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduling-and-profiling-information" title="Permalink"></a></h2><p>The collected scheduling &amp; profiling information can be visualized in a graph produced by the <a href="../references/#DataFlowTasks.plot-Tuple{Any}"><code>DataFlowTasks.plot</code></a> function (note that it requires a <code>Makie</code> backend; using <code>GLMakie</code> brings a bit more interactivity than <code>CairoMakie</code>) on the <code>logger</code> object:</p><pre><code class="language-julia hljs">DataFlowTasks.@using_opt CairoMakie # or GLMakie to benefit from more interactivity
DataFlowTasks.plot(logger; categories=[&quot;init&quot;, &quot;mutate&quot;, &quot;read&quot;])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Computing    : 0.12269270900000001
[ Info: Inserting    : 9.5e-6
[ Info: Other        : 3.5999999976444584e-5</code></pre><p><img src="../profiling_example.png" alt="ProfilingExampleTrace"/></p><p>The <code>categories</code> keyword argument allows grouping tasks in categories according to their labels. In the example above, all tasks containing <code>&quot;mutate&quot;</code> in their label will be grouped in the same category.</p><p>Note : be careful with giving similar labels. If tasks have &quot;R&quot; and &quot;RW&quot; labels, and the substrings given to the plot&#39;s argument are also &quot;R&quot;, and &quot;RW&quot;, then all tasks will be in the category &quot;R&quot; (because &quot;R&quot; can be found in &quot;RW&quot;). Regular expressions can be given instead of substrings in order to avoid such issues.</p><p>Let us explore the various parts of this graph.</p><h3 id="Parallel-Trace"><a class="docs-heading-anchor" href="#Parallel-Trace">Parallel Trace</a><a id="Parallel-Trace-1"></a><a class="docs-heading-anchor-permalink" href="#Parallel-Trace" title="Permalink"></a></h3><p>The main plot (at the top) is the parallel trace visualization. In this example there were two threads; we can see on which thread the task was run, and the time it took.</p><p>Even though tasks are grouped in categories by considering substrings in their labels, the full label is shown when hovering over a task in the interactive visualization (i.e. when using <code>GLMakie</code> instead of <code>CairoMakie</code>).</p><p>The plot also shows the time spent inserting nodes in the graph (which is part of the overhead incurred by the use of <code>DataFlowTasks</code>): these insertion times are visualized as red tasks. They are not visible for such a small example, but the interactive visualization allows zooming on the plot to search for those small tasks.</p><p>Also note that inserting tasks into the graph involves memory allocations, and may thus trigger garbage collector sweeps. When this happens, the time spent in the garbage collector is also shown in the plot.</p><h3 id="Activity-plot"><a class="docs-heading-anchor" href="#Activity-plot">Activity plot</a><a id="Activity-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Activity-plot" title="Permalink"></a></h3><p>The &quot;activity&quot; barplot (in the bottom left corner of the window) gives us information on the break-down of parallel computing times (summed over all threads):</p><ul><li><code>Computing</code> represents the total time spent in the tasks bodies (i.e. &quot;useful&quot; work);</li><li><code>Inserting</code> represents the total time spent inserting nodes in the DAG (i.e. overhead induced by <code>DataFlowTasks</code>), possibly including any time spent in the GC if it is triggered by a memory allocation in the task insertion process;</li><li><code>Other</code> represents the total idle time on all threads (which may be due to bad scheduling, or simply arise by lack of enough exposed parallelism in the algorithm).</li></ul><h3 id="Time-Bounds-plot"><a class="docs-heading-anchor" href="#Time-Bounds-plot">Time Bounds plot</a><a id="Time-Bounds-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Bounds-plot" title="Permalink"></a></h3><p>The &quot;Time Bounds&quot; barplot (in the bottom center of the window) tries to present insightful information about the performance limiting factors in the computation:</p><ul><li><code>critical path</code> represents the time spent in the longest sequential path in the DAG (shown in red in the DAG visualization). As said above, it bounds the performance in that even infinitely many threads would still have to compute this path sequentially;</li><li><code>without waiting</code> represents the duration of a hypothetical computation in which all computing time would be evenly distributed among threads (i.e. no thread would ever have to wait). This also bounds the total time because it does not account for dependencies between tasks.</li><li><code>Real</code> represents the measured &quot;wall clock time&quot; of the computation; it should be larger than both of the aforementioned bounds.</li></ul><p>When looking for faster response times, this graph may suggest sensible ways to explore. If the measured time is close to the critical path duration, then adding more threads will be of no help, but decomposing the work in smaller tasks may be useful. On the other hand, if the measured time is close to the &quot;without waiting&quot; bound, then adding more workers may reduce the wall clock time and scale relatively well.</p><h3 id="Times-per-Category-plot"><a class="docs-heading-anchor" href="#Times-per-Category-plot">Times per Category plot</a><a id="Times-per-Category-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Times-per-Category-plot" title="Permalink"></a></h3><p>The &quot;Times per Category&quot; barplot (in the bottom right of the window) displays the total time spent on all threads while performing user-defined tasks (grouped by category as explained above).</p><p>When trying to optimize the sequential performance of the algorithm, this is where one can get data about what actually takes time (and therefore could produce large gains in performance if it could be optimized).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Getting started</a><a class="docs-footer-nextpage" href="../examples/cholesky/cholesky/">Tiled Cholesky Factorization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 19 September 2022 17:21">Monday 19 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
