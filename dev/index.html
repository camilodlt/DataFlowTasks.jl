<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting started · DataFlowTasks.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://maltezfaria.github.io/DataFlowTasks.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DataFlowTasks.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Getting started</a><ul class="internal"><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Custom-types"><span>Custom types</span></a></li><li><a class="tocitem" href="#Scheduler"><span>Scheduler</span></a></li><li><a class="tocitem" href="#Limitations"><span>Limitations</span></a></li></ul></li><li><a class="tocitem" href="profiling/">Debugging &amp; Profiling</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="examples/cholesky/cholesky/">Tiled Cholesky Factorization</a></li><li><a class="tocitem" href="examples/stencil/stencil/">Iterative Stencil Loop</a></li><li><a class="tocitem" href="examples/lu/lu/">Tiled LU factorization</a></li><li><a class="tocitem" href="examples/hmat/hmat/">Hierarchical <code>LU</code> factorization</a></li></ul></li><li><a class="tocitem" href="issues/">Common Issues</a></li><li><a class="tocitem" href="references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting started</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting started</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/maltezfaria/DataFlowTasks.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DataFlowTasks"><a class="docs-heading-anchor" href="#DataFlowTasks">DataFlowTasks</a><a id="DataFlowTasks-1"></a><a class="docs-heading-anchor-permalink" href="#DataFlowTasks" title="Permalink"></a></h1><p><em>Tasks which automatically respect data-flow dependencies</em></p><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>This package defines a <a href="references/#DataFlowTasks.DataFlowTask"><code>DataFlowTask</code></a> type which behaves very much like a Julia native <code>Task</code>, except that it allows the user to specify explicit <em>data dependencies</em>. This information is then be used to automatically infer <em>task dependencies</em> by constructing and analyzing a directed acyclic graph based on how tasks access the underlying data. The premise is that it is sometimes simpler to specify how <em>tasks depend on data</em> than to specify how <em>tasks depend on each other</em>.</p><p>The use of a <a href="references/#DataFlowTasks.DataFlowTask"><code>DataFlowTask</code></a> object is intended to be as similar as possible to a Julia native <code>Task</code>. The API implements three macros :</p><ul><li><a href="references/#DataFlowTasks.@dspawn-Tuple{Any, Vararg{Any}}"><code>@dspawn</code></a></li><li><a href="references/#DataFlowTasks.@dtask-Tuple{Any, Vararg{Any}}"><code>@dtask</code></a></li><li><a href="references/#DataFlowTasks.@dasync-Tuple{Any, Vararg{Any}}"><code>@dasync</code></a></li></ul><p>which behave like their <code>Base</code> counterparts, except they take additional annotations that declare how each <em>task</em> affects the <em>data</em> it accesses:</p><ul><li>read-only: <code>@R</code> or <code>@READ</code></li><li>write-only: <code>@W</code> or <code>@WRITE</code></li><li>read-write: <code>@RW</code> or <code>@READWRITE</code></li></ul><p>Anywhere in the task body, a <code>@R(A)</code> annotation for example implies that <em>data</em> <code>A</code> will be accessed in read-only mode by the <em>task</em>.</p><pre><code class="language-julia hljs">A = ones(5)
B = ones(5)
d = @dspawn begin
    @RW A   # A is accessed in READWRITE mode
    @R  B   # B is accessed in READ mode
    A .= A .+ B
end

fetch(d)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">5-element Vector{Float64}:
 2.0
 2.0
 2.0
 2.0
 2.0</code></pre><p>This creates (and schedules for execution) a <code>DataFlowTask</code> <code>d</code> which accesses <code>A</code> in <code>READWRITE</code> mode, and <code>B</code> in <code>READ</code> mode. The benefit of <code>DataFlowTasks</code> comes when you start to compose operations which may mutate the same data:</p><pre><code class="language-julia hljs">n = 100_000
A = ones(n)

d1 = @dspawn begin
    @RW A

    # in-place work on A
    for i in eachindex(A)
        A[i] = log(A[i]) # A[i] = 0
    end
end

# reduce A
d2 = @dspawn sum(@R A)
# The above is a shortcut for:
#   d2 = @dspawn begin
#       @R A
#       sum(A)
#   end

c = fetch(d2) # 0</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>We now have two asynchronous tasks being created, both of which access the array <code>A</code>. Because <code>d1</code> writes to <code>A</code>, and <code>d2</code> reads from it, the outcome <code>C</code> is nondeterministic unless we specify an order of precedence. <code>DataFlowTasks</code> reinforces the <strong>sequential consistency</strong> criterion, which is to say that executing tasks in parallel must preserve, up to rounding errors, the result that would have been obtained if they were executed sequentially (i.e. <code>d1</code> is executed before <code>d2</code>, <code>d2</code> before <code>d3</code>, and so on). In this example, this means <code>d2</code> will always wait on <code>d1</code> because of an inferred data dependency. The outcome is thus always zero.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>If you replace <code>@dspawn</code> by <code>Threads.@spawn</code> in the example above (and pick an <code>n</code> large enough) you will see that you no longer get <code>0</code> because <code>d2</code> may access an element of <code>A</code> before it has been replaced by zero!</p></div></div><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>In the <code>d2</code> example above, a shortcut syntax was introduced, which allows putting access mode annotations directly around arguments in a function call. This is especially useful when the task body is a one-liner.</p><p>See <a href="references/#DataFlowTasks.@dspawn-Tuple{Any, Vararg{Any}}"><code>@dspawn</code></a> for an exhaustive list of supported ways to create tasks and specify data dependencies.</p></div></div><p>No parallelism was allowed in the previous example due to a data conflict. To see that when parallelism is possible, <code>DataFlowTasks</code> will exploit it, consider this one last example:</p><pre><code class="language-julia hljs">n = 100
A = ones(n)

d1 = @dspawn begin
    @W A

    # write to A
    sleep(1)
    fill!(A,0)
end

d2 = @dspawn begin
    @R A

    # some long computation
    sleep(5)
    # reduce A
    sum(A)
end

# another reduction on A
d3 = @dspawn sum(x-&gt;sin(x), @R(A))

t = @elapsed c = fetch(d3)

t,c</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(0.89268387, 0.0)</code></pre><p>We see that the elapsed time to <code>fetch</code> the result from <code>d3</code> is on the order of one second. This is expected since <code>d3</code> needs to wait on <code>d1</code> but can be executed concurrently with <code>d2</code>. The result is, as expected, <code>0</code>.</p><p>All examples this far have been simple enough that the dependencies between the tasks could have been inserted <em>by hand</em>. There are certain problems, however, where the constant reuse of memory (mostly for performance reasons) makes a data-flow approach to parallelism a rather natural way to implicitly describe task dependencies. This is the case, for instance, of tiled (also called blocked) matrix factorization algorithms, where task dependencies can become rather difficult to describe in an explicit manner. The <a href="examples/cholesky/cholesky/#tiledcholesky-section">tiled factorization section</a> showcases some non-trivial problems for which <code>DataFlowTask</code>s may be useful.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The main goal of <code>DataFlowTask</code>s is to expose parallelism: two tasks <code>ti</code> and <code>tj</code> can be executed concurrently if one does not write to memory that the other reads. This data-dependency check is done <em>dynamically</em>, and therefore is not limited to tasks in the same lexical scope. Of course, there is an overhead associated with these checks, so whether performance gains can be obtained depend largely on how parallel the algorithm is, as well as how long each individual task takes (compared to the overhead).</p></div></div><h2 id="Custom-types"><a class="docs-heading-anchor" href="#Custom-types">Custom types</a><a id="Custom-types-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-types" title="Permalink"></a></h2><p>In order to infer dependencies between <code>DataFlowTask</code>s, we must be able to determine whether two objects <code>A</code> and <code>B</code> share a common memory space. That is to say, we must know if <em>mutating</em> <code>A</code> can affect <code>B</code>, or vice-versa. Obviously, without any further information on the types of <code>A</code> and <code>B</code>, this is an impossible question.</p><p>To get around this challenge, you must <code>import</code> and extend the <a href="references/#DataFlowTasks.memory_overlap-Tuple{Any, Any}"><code>memory_overlap</code></a> method to work on any pair of elements <code>A</code> and <code>B</code> that you wish to use. The examples in the previous section worked because these methods have been defined for some basic <code>AbstractArray</code>s:</p><pre><code class="language-julia hljs">using DataFlowTasks: memory_overlap

A = rand(10,10)
B = view(A,1:10)
C = view(A,11:20)

memory_overlap(A,B),memory_overlap(A,C),memory_overlap(B,C)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(true, true, false)</code></pre><p>By default, <code>memory_overlap</code> will return <code>true</code> and print a warning if it does not find a specialized method:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DataFlowTasks: memory_overlap</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; struct CirculantMatrix
           data::Vector{Float64}
       end</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = rand(10);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = CirculantMatrix(v);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; memory_overlap(M,copy(v))</code><code class="nohighlight hljs ansi" style="display:block;">┌ Warning: memory_overlap(::Main.var&quot;Main&quot;.CirculantMatrix,::Vector{Float64}) not implemented. Defaulting to `true`
└ @ DataFlowTasks ~/work/DataFlowTasks.jl/DataFlowTasks.jl/src/dataflowtask.jl:153
true</code></pre><p>Extending the <code>memory_overlap</code> will remove the warning, and produce a more meaningful result:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; import DataFlowTasks: memory_overlap</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # overload the method
       memory_overlap(M::CirculantMatrix,v) = memory_overlap(M.data,v)</code><code class="nohighlight hljs ansi" style="display:block;">memory_overlap (generic function with 8 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; memory_overlap(v,M::CirculantMatrix) = memory_overlap(M,v)</code><code class="nohighlight hljs ansi" style="display:block;">memory_overlap (generic function with 9 methods)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; memory_overlap(M,v), memory_overlap(M,copy(v))</code><code class="nohighlight hljs ansi" style="display:block;">(true, false)</code></pre><p>You can now <code>spawn</code> tasks with your custom type <code>CirculantMatrix</code> as a data dependency, and things should work as expected:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using DataFlowTasks</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v  = ones(5);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M1 = CirculantMatrix(v);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M2 = CirculantMatrix(copy(v));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Base.sum(M::CirculantMatrix) = length(M.data)*sum(M.data)</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d1 = @dspawn begin
           @W v
           sleep(0.5)
           fill!(v,0)
       end;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d2 = @dspawn sum(@R M1)</code><code class="nohighlight hljs ansi" style="display:block;">DataFlowTask (runnable) 129</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; d3 = @dspawn sum(@R M2)</code><code class="nohighlight hljs ansi" style="display:block;">DataFlowTask (done) 130</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fetch(d3) # 25</code><code class="nohighlight hljs ansi" style="display:block;">25.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fetch(d2) # 0</code><code class="nohighlight hljs ansi" style="display:block;">0.0</code></pre><h2 id="Scheduler"><a class="docs-heading-anchor" href="#Scheduler">Scheduler</a><a id="Scheduler-1"></a><a class="docs-heading-anchor-permalink" href="#Scheduler" title="Permalink"></a></h2><p>When loaded, the <code>DataFlowTasks</code> package will initialize an internal scheduler (of type <a href="references/#DataFlowTasks.JuliaScheduler"><code>JuliaScheduler</code></a>), running on the background, to handle implicit dependencies of the spawned <code>DataFlowTask</code>s. In order to retrieve the current scheduler, you may use the <a href="references/#DataFlowTasks.getscheduler-Tuple{}"><code>getscheduler</code></a> method:</p><pre><code class="language-julia hljs">sch = DataFlowTasks.getscheduler()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataFlowTasks.JuliaScheduler{DataFlowTasks.DataFlowTask} with 0 active nodes, 0 finished nodes, and 0 edges (capacity of 50 nodes)</code></pre><p>The default scheduler can be changed through <a href="references/#DataFlowTasks.setscheduler!-Tuple{Any}"><code>setscheduler!</code></a>.</p><p>There are two important things to know about the default <code>JuliaScheduler</code> type. First, it contains a buffered DAG that can handle up to <code>sz_max</code> nodes: trying to <code>spawn</code> a task when the DAG is full will block. This is done to keep the cost of analyzing the data dependencies under control, and it means that a full/static DAG may in practice never be constructed. You can modify the buffer size as follows:</p><pre><code class="language-julia hljs">resize!(sch.dag,50)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">50</code></pre><p>Second, when the computation of a <code>DataFlowTask</code> <code>ti</code> is completed, it gets pushed into a <code>finished</code> channel, to be eventually processed and <code>pop</code>ed from the DAG by the <code>dag_worker</code>. This is done to avoid concurrent access to the DAG: only the <code>dag_worker</code> should modify it. If you want to stop nodes from being removed from the DAG, you may stop the <code>dag_worker</code> using:</p><pre><code class="language-julia hljs">DataFlowTasks.stop_dag_worker(sch)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Task (done) @0x00007fdda8ea26e0</code></pre><p>Finished nodes will now remain in the DAG:</p><pre><code class="language-julia hljs">using DataFlowTasks: R,W,RW, num_nodes
A = ones(5)
@dspawn begin
    @RW A
    A .= 2 .* A
end
@dspawn sum(@R A)
sch</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataFlowTasks.JuliaScheduler{DataFlowTasks.DataFlowTask} with 2 active nodes, 2 finished nodes, and 1 edge (capacity of 50 nodes)</code></pre><p>Note that stopping the <code>dag_worker</code> means <code>finished</code> nodes are no longer removed from the DAG; since the DAG is a buffered structure, this may cause the execution to halt if the DAG is at full capacity. You can then either <code>resize!</code> it, or simply start the worker (which will result in the processing of the <code>finished</code> channel):</p><pre><code class="language-julia hljs">DataFlowTasks.start_dag_worker(sch)
sch</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataFlowTasks.JuliaScheduler{DataFlowTasks.DataFlowTask} with 0 active nodes, 0 finished nodes, and 0 edges (capacity of 50 nodes)</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>There are situations where you may want to change the default scheduler temporarily to execute a block of code, and revert to the default scheduler after. This can be done using the <a href="references/#DataFlowTasks.with_scheduler-Tuple{Any, Any}"><code>with_scheduler</code></a> method. </p></div></div><h2 id="Limitations"><a class="docs-heading-anchor" href="#Limitations">Limitations</a><a id="Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Limitations" title="Permalink"></a></h2><p>Some current limitations are listed below:</p><ul><li>There is no way to specify priorities for a task.</li><li>The main thread executes tasks, and is responsible for adding/removing nodes from the DAG. This may hinder parallelism if the main thread is given a long task since the processing of the dag will halt until the main thread becomes free again.</li><li>...</li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="profiling/">Debugging &amp; Profiling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 6 September 2022 13:37">Tuesday 6 September 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
